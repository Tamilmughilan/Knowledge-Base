package com.knowledgebase.backend.controllers;

import com.knowledgebase.backend.models.Doc;
import com.knowledgebase.backend.models.Version;
import com.knowledgebase.backend.repositories.DocumentRepository;
import com.knowledgebase.backend.repositories.VersionRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/versions")
@CrossOrigin(origins = "http://localhost:3000")
public class VersionController {
    
    @Autowired
    private VersionRepository versionRepo;
    
    @Autowired
    private DocumentRepository docRepo;
    
    private final String uploadDir = "uploads/";
    
    // Get all versions for a document
    @GetMapping("/document/{documentId}")
    public List<Version> getVersionsByDocument(@PathVariable String documentId) {
        return versionRepo.findByDocumentIdOrderByVersionNumberDesc(documentId);
    }
    
    // Upload new version
    @PostMapping("/document/{documentId}")
    @PreAuthorize("hasAnyRole('CONTRIBUTOR', 'ADMIN')")
    public ResponseEntity<?> uploadVersion(
            @PathVariable String documentId,
            @RequestParam("file") MultipartFile file,
            @RequestParam(required = false) String comment,
            Authentication auth) throws IOException {
        
        Optional<Doc> docOpt = docRepo.findById(documentId);
        if (docOpt.isEmpty()) {
            return ResponseEntity.notFound().build();
        }
        
        // Create upload directory if not exists
        Path uploadPath = Paths.get(uploadDir);
        if (!Files.exists(uploadPath)) {
            Files.createDirectories(uploadPath);
        }
        
        // Get next version number
        Optional<Version> latestVersion = versionRepo.findTopByDocumentIdOrderByVersionNumberDesc(documentId);
        int nextVersion = latestVersion.map(v -> v.getVersionNumber() + 1).orElse(1);
        
        // Save file
        String fileName = documentId + "_v" + nextVersion + "_" + file.getOriginalFilename();
        Path filePath = uploadPath.resolve(fileName);
        Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);
        
        // Create version record
        Version version = new Version();
        version.setDocumentId(documentId);
        version.setVersionNumber(nextVersion);
        version.setFileName(file.getOriginalFilename());
        version.setFilePath(filePath.toString());
        version.setMimeType(file.getContentType());
        version.setFileSize(file.getSize());
        version.setUploadedBy(auth.getName());
        version.setUploadComment(comment != null ? comment : "Version " + nextVersion);
        
        Version saved = versionRepo.save(version);
        
        // Update document's current version
        Doc doc = docOpt.get();
        doc.setCurrentVersionId(saved.getId());
        docRepo.save(doc);
        
        return ResponseEntity.ok(saved);
    }
    
    // Download a specific version
    @GetMapping("/{versionId}/download")
    public ResponseEntity<Resource> downloadVersion(@PathVariable String versionId) throws IOException {
        Optional<Version> versionOpt = versionRepo.findById(versionId);
        if (versionOpt.isEmpty()) {
            return ResponseEntity.notFound().build();
        }
        
        Version version = versionOpt.get();
        Path filePath = Paths.get(version.getFilePath());
        Resource resource = new UrlResource(filePath.toUri());
        
        if (!resource.exists() || !resource.isReadable()) {
            return ResponseEntity.notFound().build();
        }
        
        // Determine content type
        String contentType = version.getMimeType();
        if (contentType == null) {
            contentType = "application/octet-stream";
        }
        
        return ResponseEntity.ok()
                .contentType(MediaType.parseMediaType(contentType))
                .header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"" + version.getFileName() + "\"")
                .body(resource);
    }
    
    // View file in browser (for PDFs)
    @GetMapping("/{versionId}/view")
    public ResponseEntity<Resource> viewVersion(@PathVariable String versionId) throws IOException {
        Optional<Version> versionOpt = versionRepo.findById(versionId);
        if (versionOpt.isEmpty()) {
            return ResponseEntity.notFound().build();
        }
        
        Version version = versionOpt.get();
        Path filePath = Paths.get(version.getFilePath());
        Resource resource = new UrlResource(filePath.toUri());
        
        if (!resource.exists() || !resource.isReadable()) {
            return ResponseEntity.notFound().build();
        }
        
        String contentType = version.getMimeType();
        if (contentType == null) {
            contentType = "application/octet-stream";
        }
        
        return ResponseEntity.ok()
                .contentType(MediaType.parseMediaType(contentType))
                .header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"" + version.getFileName() + "\"")
                .header(HttpHeaders.CACHE_CONTROL, "no-cache, no-store, must-revalidate")
                .body(resource);
    }
    
    // Rollback to a previous version (ADMIN only)
    @PostMapping("/{versionId}/rollback")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> rollback(@PathVariable String versionId) {
        Optional<Version> versionOpt = versionRepo.findById(versionId);
        if (versionOpt.isEmpty()) {
            return ResponseEntity.notFound().build();
        }
        
        Version version = versionOpt.get();
        Optional<Doc> docOpt = docRepo.findById(version.getDocumentId());
        if (docOpt.isEmpty()) {
            return ResponseEntity.notFound().build();
        }
        
        Doc doc = docOpt.get();
        doc.setCurrentVersionId(versionId);
        docRepo.save(doc);
        
        return ResponseEntity.ok().build();
    }
}